import { html, render, nothing } from "lit-html";

import { lang, GM_fetch } from "./utils/utils.js";
import { convertSubs } from "@vot.js/shared/utils/subs";

export class SubtitlesProcessor {
  static formatYandexTokens(line) {
    const lineEndMs = line.startMs + line.durationMs;
    return line.tokens.reduce((result, token, index) => {
      const nextToken = line.tokens[index + 1];
      const lastToken = result[result.length - 1];
      const alignRangeEnd = lastToken?.alignRange?.end ?? 0;
      const newAlignRangeEnd = alignRangeEnd + token.text.length;

      token.alignRange = {
        start: alignRangeEnd,
        end: newAlignRangeEnd,
      };
      result.push(token);

      if (nextToken) {
        const endMs = token.startMs + token.durationMs;
        const durationMs = nextToken.startMs
          ? nextToken.startMs - endMs
          : lineEndMs - endMs;

        result.push({
          text: " ",
          startMs: endMs,
          durationMs,
          alignRange: {
            start: newAlignRangeEnd,
            end: newAlignRangeEnd + 1,
          },
        });
      }
      return result;
    }, []);
  }

  static createTokens(line, previousLineLastToken) {
    const tokens = line.text.split(/([\n \t])/).reduce((result, tokenText) => {
      if (!tokenText.length) return result;

      const lastToken = result[result.length - 1] ?? previousLineLastToken;
      const alignRangeStart = lastToken?.alignRange?.end ?? 0;
      const alignRangeEnd = alignRangeStart + tokenText.length;

      result.push({
        text: tokenText,
        alignRange: {
          start: alignRangeStart,
          end: alignRangeEnd,
        },
      });
      return result;
    }, []);

    const tokenDurationMs = Math.floor(line.durationMs / tokens.length);
    const lineEndMs = line.startMs + line.durationMs;

    return tokens.map((token, index) => {
      const isLastToken = index === tokens.length - 1;
      const startMs = line.startMs + tokenDurationMs * index;
      const durationMs = isLastToken ? lineEndMs - startMs : tokenDurationMs;
      return { ...token, startMs, durationMs };
    });
  }

  static processTokens(subtitles, subtitlesObject) {
    const result = [];
    let lastToken;
    const { source, isAutoGenerated } = subtitlesObject;

    for (const line of subtitles.subtitles) {
      const hasTokens = line?.tokens?.length;
      const tokens =
        hasTokens &&
        (source === "yandex" || (source === "youtube" && isAutoGenerated))
          ? this.formatYandexTokens(line)
          : this.createTokens(line, lastToken);

      lastToken = tokens[tokens.length - 1];
      result.push({ ...line, tokens });
    }

    subtitles.containsTokens = true;
    return result;
  }

  static formatYoutubeSubtitles(subtitles, isAsr = false) {
    if (!subtitles?.events?.length) {
      console.error("[VOT] Invalid YouTube subtitles format:", subtitles);
      return { containsTokens: isAsr, subtitles: [] };
    }

    const result = {
      containsTokens: isAsr,
      subtitles: [],
    };

    for (let i = 0; i < subtitles.events.length; i++) {
      const subtitle = subtitles.events[i];
      if (!subtitle.segs) continue;

      let durationMs = subtitle.dDurationMs;
      if (
        subtitles.events[i + 1] &&
        subtitle.tStartMs + subtitle.dDurationMs >
          subtitles.events[i + 1].tStartMs
      ) {
        durationMs = subtitles.events[i + 1].tStartMs - subtitle.tStartMs;
      }

      const tokens = [];
      let lastSegDuration = durationMs;

      for (let j = 0; j < subtitle.segs.length; j++) {
        const seg = subtitle.segs[j];
        const text = seg.utf8.trim();
        if (text === "\n") continue;

        const offset = seg.tOffsetMs ?? 0;
        let segDuration = durationMs;
        const nextSeg = subtitle.segs[j + 1];

        if (nextSeg?.tOffsetMs) {
          segDuration = nextSeg.tOffsetMs - offset;
          lastSegDuration -= segDuration;
        }

        tokens.push({
          text,
          startMs: subtitle.tStartMs + offset,
          durationMs: nextSeg ? segDuration : lastSegDuration,
        });
      }

      const text = tokens.map((e) => e.text).join(" ");
      if (text) {
        result.subtitles.push({
          text,
          startMs: subtitle.tStartMs,
          durationMs,
          ...(isAsr ? { tokens } : {}),
        });
      }
    }

    return result;
  }
  /**
   * Remove HTML tags from JSON subtitle text
   */
  static cleanJsonSubtitles(subtitles) {
    const { containsTokens, subtitles: subtitlesList } = subtitles;
    return {
      containsTokens,
      subtitles: subtitlesList.map((item) => ({
        ...item,
        text: item.text.replace(/(<([^>]+)>)/gi, ""),
      })),
    };
  }

  static async fetchWithTimeout(url, timeout = 5000) {
    try {
      const response = await GM_fetch(url, { timeout });
      return response;
    } catch (error) {
      console.error("[VOT] Fetch failed:", error);
      throw error;
    }
  }

  static async fetchSubtitles(subtitlesObject) {
    const { source, isAutoGenerated, format, url } = subtitlesObject;

    try {
      const response = await this.fetchWithTimeout(url);
      let subtitles;

      if (["vtt", "srt"].includes(format)) {
        const text = await response.text();
        subtitles = convertSubs(text, "json");
      } else {
        subtitles = await response.json();
      }

      if (source === "youtube") {
        subtitles = this.formatYoutubeSubtitles(subtitles, isAutoGenerated);
      }

      if (source === "vk") {
        subtitles = this.cleanJsonSubtitles(subtitles);
      }

      subtitles.subtitles = this.processTokens(subtitles, subtitlesObject);
      console.log("[VOT] Processed subtitles:", subtitles);
      return subtitles;
    } catch (error) {
      console.error("[VOT] Failed to process subtitles:", error);
      return {
        containsTokens: false,
        subtitles: [],
      };
    }
  }

  static async getSubtitles(client, videoData) {
    const {
      host,
      url,
      detectedLanguage: requestLang,
      videoId,
      duration,
      subtitles: extraSubtitles = [],
    } = videoData;

    try {
      const res = await Promise.race([
        client.getSubtitles({
          videoData: { host, url, videoId, duration },
          requestLang,
        }),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error("Timeout")), 5000),
        ),
      ]);

      console.log("[VOT] Subtitles response:", res);

      if (res.waiting) {
        console.error("[VOT] Failed to get Yandex subtitles");
      }

      const yandexSubs = (res.subtitles ?? []).reduce((result, sub) => {
        if (
          sub.language &&
          !result.find(
            (e) =>
              e.source === "yandex" &&
              e.language === sub.language &&
              !e.translatedFromLanguage,
          )
        ) {
          result.push({
            source: "yandex",
            language: sub.language,
            url: sub.url,
          });
        }

        if (sub.translatedLanguage) {
          result.push({
            source: "yandex",
            language: sub.translatedLanguage,
            translatedFromLanguage: sub.language,
            url: sub.translatedUrl,
          });
        }

        return result;
      }, []);

      return [...yandexSubs, ...extraSubtitles].sort((a, b) => {
        // Source priority
        if (a.source !== b.source) {
          return a.source === "yandex" ? -1 : 1;
        }

        // Language priority
        if (
          a.language !== b.language &&
          (a.language === lang || b.language === lang)
        ) {
          return a.language === lang ? -1 : 1;
        }

        if (a.source === "yandex") {
          // Translation priority
          if (a.translatedFromLanguage !== b.translatedFromLanguage) {
            if (!a.translatedFromLanguage || !b.translatedFromLanguage) {
              return a.language === b.language
                ? a.translatedFromLanguage
                  ? 1
                  : -1
                : !a.translatedFromLanguage
                  ? 1
                  : -1;
            }
            return a.translatedFromLanguage === requestLang ? -1 : 1;
          }

          // Non-translated language priority
          if (!a.translatedFromLanguage) {
            return a.language === requestLang ? -1 : 1;
          }
        }

        // Auto-generated priority
        if (a.source !== "yandex" && a.isAutoGenerated !== b.isAutoGenerated) {
          return a.isAutoGenerated ? 1 : -1;
        }

        return 0;
      });
    } catch (error) {
      const message =
        error.message === "Timeout"
          ? "Failed to get Yandex subtitles: timeout"
          : "Error in getSubtitles function";
      console.error(`[VOT] ${message}`, error);
      // на сайтах, где нет сабов всегда красит кнопку
      throw error;
    }
  }
}

export class SubtitlesWidget {
  constructor(video, container, site) {
    this.video = video;
    this.container =
      site.host === "youtube" && site.additionalData !== "mobile"
        ? container.parentElement
        : container;
    this.site = site;

    this.subtitlesContainer = this.createSubtitlesContainer();
    this.position = { left: 25, top: 75 };
    this.dragging = { active: false, offset: { x: 0, y: 0 } };

    this.subtitles = null;
    this.lastContent = null;
    this.highlightWords = false;
    this.fontSize = 20;
    this.opacity = 0.2;
    this.maxLength = 300;

    this.abortController = new AbortController();
    this.bindEvents();
    this.updateContainerRect();
  }

  createSubtitlesContainer() {
    this.subtitlesContainer = document.createElement("vot-block");
    this.subtitlesContainer.classList.add("vot-subtitles-widget");
    this.container.appendChild(this.subtitlesContainer);
    return this.subtitlesContainer;
  }

  bindEvents() {
    const { signal } = this.abortController;
    this.onPointerDownBound = (e) => this.onPointerDown(e);
    this.onPointerUpBound = () => this.onPointerUp();
    this.onPointerMoveBound = (e) => this.onPointerMove(e);
    this.onTimeUpdateBound = this.debounce(() => this.update(), 100);

    document.addEventListener("pointerdown", this.onPointerDownBound, {
      signal,
    });
    document.addEventListener("pointerup", this.onPointerUpBound, { signal });
    document.addEventListener("pointermove", this.onPointerMoveBound, {
      signal,
    });

    this.video?.addEventListener("timeupdate", this.onTimeUpdateBound, {
      signal,
    });
    this.resizeObserver = new ResizeObserver(() => this.onResize());
    this.resizeObserver.observe(this.container);
  }

  onPointerDown(e) {
    if (!this.subtitlesContainer.contains(e.target)) return;

    const rect = this.subtitlesContainer.getBoundingClientRect();
    const containerRect = this.container.getBoundingClientRect();

    this.dragging = {
      active: true,
      offset: {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top,
      },
      containerOffset: {
        x: containerRect.left,
        y: containerRect.top,
      },
    };
  }
  onPointerUp() {
    this.dragging.active = false;
  }

  onPointerMove(e) {
    if (!this.dragging.active) return;

    e.preventDefault();
    const { width, height } = this.container.getBoundingClientRect();
    const { containerOffset, offset } = this.dragging;

    this.position = {
      left: ((e.clientX - offset.x - containerOffset.x) / width) * 100,
      top: ((e.clientY - offset.y - containerOffset.y) / height) * 100,
    };

    this.applySubtitlePosition();
  }

  onResize() {
    this.updateContainerRect();
  }

  updateContainerRect() {
    this.containerRect = this.container.getBoundingClientRect();
    this.applySubtitlePosition();
  }

  applySubtitlePosition() {
    const { width, height } = this.containerRect;
    const { offsetWidth, offsetHeight } = this.subtitlesContainer;

    const maxLeft = ((width - offsetWidth) / width) * 100;
    const maxTop = ((height - offsetHeight) / height) * 100;

    this.position.left = Math.max(0, Math.min(this.position.left, maxLeft));
    this.position.top = Math.max(0, Math.min(this.position.top, maxTop));

    this.subtitlesContainer.style.left = `${this.position.left}%`;
    this.subtitlesContainer.style.top = `${this.position.top}%`;
  }

  processTokens(tokens) {
    if (tokens.at(-1).alignRange.end <= this.maxLength) return tokens;

    const chunks = [];
    let chunkTokens = [];
    let length = 0;

    for (const token of tokens) {
      length += token.text.length;
      chunkTokens.push(token);

      if (length > this.maxLength) {
        chunks.push(this.trimChunk(chunkTokens));
        chunkTokens = [];
        length = 0;
      }
    }

    if (chunkTokens.length) chunks.push(this.trimChunk(chunkTokens));

    const time = this.video.currentTime * 1000;
    return (
      chunks.find(
        (chunk) =>
          chunk[0].startMs < time &&
          time < chunk.at(-1).startMs + chunk.at(-1).durationMs,
      ) || chunks[0]
    );
  }

  trimChunk(tokens) {
    if (tokens[0]?.text === " ") tokens.shift();
    if (tokens.at(-1)?.text === " ") tokens.pop();
    return tokens;
  }

  renderTokens(tokens, time) {
    return tokens.map((token) => {
      const passed =
        this.highlightWords &&
        (time > token.startMs + token.durationMs / 2 ||
          (time > token.startMs - 100 &&
            token.startMs + token.durationMs / 2 - time < 275));

      return html`<span class="${passed ? "passed" : nothing}">
        ${token.text.replace("\\n", "<br>")}
      </span>`;
    });
  }

  debounce(func, wait) {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }

  setContent(subtitles) {
    if (!subtitles || !this.video) {
      this.subtitles = null;
      render(null, this.subtitlesContainer);
      return;
    }

    this.subtitles = subtitles;
    this.update();
  }

  setMaxLength(len) {
    if (typeof len === "number" && len > 0) {
      this.maxLength = len;
      this.update();
    }
  }

  setHighlightWords(value) {
    this.highlightWords = Boolean(value);
    this.update();
  }

  setFontSize(size) {
    this.fontSize = size;
    const subtitlesEl =
      this.subtitlesContainer?.querySelector(".vot-subtitles");
    if (subtitlesEl) {
      subtitlesEl.style.fontSize = `${size}px`;
    }
  }

  /**
   * Set subtitles opacity by percentage where 100 - full transparent, 0 - not transparent
   *
   * @param {number} rate - 0-100 percent of opacity
   */
  setOpacity(rate) {
    this.opacity = ((100 - +rate) / 100).toFixed(2);
    const subtitlesEl =
      this.subtitlesContainer?.querySelector(".vot-subtitles");
    if (subtitlesEl) {
      subtitlesEl.style.setProperty("--vot-subtitles-opacity", this.opacity);
    }
  }

  update() {
    if (!this.video || !this.subtitles) return;

    const time = this.video.currentTime * 1000;
    const line = this.subtitles.subtitles.findLast(
      (e) => e.startMs < time && time < e.startMs + e.durationMs,
    );

    if (!line) {
      render(null, this.subtitlesContainer);
      return;
    }

    const tokens = this.processTokens(line.tokens);
    const content = this.renderTokens(tokens, time);
    const stringContent = JSON.stringify(content);

    if (stringContent !== this.lastContent) {
      this.lastContent = stringContent;
      render(
        html`<vot-block
          class="vot-subtitles"
          style="font-size: ${this.fontSize}px; --vot-subtitles-opacity: ${this
            .opacity}"
          >${content}</vot-block
        >`,
        this.subtitlesContainer,
      );
    }
  }

  release() {
    this.abortController.abort();
    this.resizeObserver.disconnect();
    this.subtitlesContainer.remove();
  }
}
